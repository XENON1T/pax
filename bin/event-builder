#!/usr/bin/env python
"""Command line script for driving the XENON1T event builder

The event builder is responsible for turning the DAQ output (a stream of dititizer pulses)
into a zipped BSON with events ready for processing.

This code will need to make a connection to the XENON1T runs database, as the event builder
uses the runs database database to locate what data needs to be processed,
get appropriate settings for each run, and write status information when done with a run.

The data generated by the event builder will be placed in /data/xenon1t/run_name.
"""
import argparse
import logging
import os
import time
import datetime
import socket
import shutil

from six.moves import input
import pymongo

from pax import core, units
from pax.plugins.io.MongoDB import ClientMaker


def get_hostname():
    return socket.gethostname().split('.')[0]


def main():
    """Start running the event builder
    """
    args = get_command_line_arguments()
    log = setup_logging(loglevel=args.log.upper())

    # Check for strange arugment combinations
    if args.stop_after_sec < float('inf') and not args.secret_mode:
        print("You are about to stop the trigger after %d sec of data in the run, which means you are probably testing "
              "something out. However, you have NOT enabled secret mode and will be writing to official runs db!\n"
              "Are you sure??" % args.stop_after_sec)
        if input().lower() not in ('y', 'yes'):
            print("\nFine, Exiting event builder...\n")
            exit()
    if args.secret_mode and not (args.run or args.run_name):
        raise RuntimeError("Secret mode doesn't support wait-for-runs-mode (too lazy right now)")

    # Connect to MongoDB
    clientmaker = ClientMaker(config={k: eval('args.%s' % k, dict(args=args))
                                      for k in ('user', 'password', 'host', 'port')})
    runs = clientmaker.get_client('run')['run'].get_collection('runs_new')

    # Build the query used to search for runs
    status_name = 'trigger.status'
    if args.run_name:
        run_query = {'name': args.run_name}
    elif args.run is not None:
        run_query = {'number': args.run}
    else:
        run_query = {status_name: 'waiting_to_be_processed',
                     'data.type': 'untriggered'}
    run_query['detector'] = args.detector
    log.info("Starting run search with query %s" % run_query)

    while 1:
        if not args.secret_mode:
            run_doc = runs.find_one_and_update(run_query, {'$set': {status_name: 'staging'}})

            if run_doc is not None:
                data_info_entry = {'type': 'raw',
                                   'host': get_hostname(),
                                   'status': 'transferring',
                                   'location': os.path.join('/data/xenon1t_data', run_doc['name']),
                                   'creation_time' : datetime.datetime.utcnow(),
                                   'checksum': None}
                runs.update({'_id': run_doc['_id']},
                            {'$push': {'data': data_info_entry}})
        else:
            run_doc = runs.find_one(run_query)
            if run_doc is None:
                raise ValueError("Mongodb returned None instead of run document!")
            data_info_entry = dict(location=os.path.join('.', run_doc['name']))
            
        if run_doc is None:
            if args.wait <= 0:
                log.info("No runs to process: exiting.")
                break
            log.info("No runs to process yet... waiting %d seconds", args.wait)
            time.sleep(args.wait)
            continue

        # Build configuration for pax. Settings priority:
        #   First priority: command line args
        #   Second priority: rundb settings (from run_doc['trigger']), from previous runs
        #   Third priority: defaults from pax configuration (pax will take care of loading these)
        # Unit conversion factors are applied to the command line args, but NOT to the rundb values!
        # (to do that, we'd have to un-convert them when we later store the settings we actually used)

        # Load run doc settings + basic settings
        # run_doc should not try to override something from 'pax', 'DEFAULT', etc.
        config_dict = run_doc['trigger'].get('config_of_runmode', {})
        config_dict.update({'DEFAULT': {'run_doc_id': run_doc['_id']},
                            'pax': {'output_name': data_info_entry['location'],
                                    'n_cpus': args.cpus},
                            'BSON': {'fields_to_ignore': [],
                                     'overwrite_output': True}})

        # Apply command-line override settings for MongoDB
        mongo_settings_override = {}
        for argname in ('detector', 'secret_mode',
                        'host', 'port', 'user', 'password',
                        'batch_window', 'delete_data', 'edge_safety_margin', 'skip_ahead', 'stop_after_sec'):
            argval = getattr(args, argname)
            if argval is None:
                continue
            if argname == 'edge_safety_margin':
                 argval *= units.s
            mongo_settings_override[argname] = argval
        config_dict['MongoDB'] = config_dict.get('MongoDB', {}).update(mongo_settings_override)

        # Apply command-line override settings for trigger
        trigger_settings_override = {}
        for argname, factor in (('left_extension', units.us),
                                ('right_extension', units.us),
                                ('signal_separation', units.us),
                                ('event_separation', units.us)):
            argval = getattr(args, argname)
            if argval is not None:
                if factor is not None:
                    argval = int(factor * argval)
                trigger_settings_override[argname] = argval
        trigger_settings_override['trigger_monitor_file_path'] = os.path.join(data_info_entry['location'],
                                                                              'trigger_monitor_data.zip')
        config_dict['Trigger'] = config_dict.get('Trigger', {}).update(trigger_settings_override)

        # Apply command-line override settings for trigger probability
        if args.force_multiplicity_trigger is not None:
            level = args.force_multiplicity_trigger
            config_dict.setdefault('Trigger.DecideTriggers', {})
            config_dict['Trigger.DecideTriggers']['trigger_probability'] = {
                '0': {str(level): 1},
                '1': {str(level): 1},
                '2': {str(level): 1}}

        log.info("Building events for %s", run_doc['name'])
        try:
            p = core.Processor(config_names=['XENON1T' if args.detector == 'tpc' else 'XENON1T_MV'] + args.config,
                               config_paths=args.config_path,
                               config_dict=config_dict)
            p.run()     # The run() method includes a call to shutdown()

        # If a timeout occurred, set the status of this run to 'error'
        # Add other exceptions as they come during commissioning
        except pymongo.errors.ServerSelectionTimeoutError as e:
            log.exception(e)
            runs.update({'name': run_doc['name'], 'detector' : args.detector},
                        {'$set': {status_name: 'error'}})

        # Copy the log file to the output dir, then clear it for the next run
        shutil.copyfile('eventbuilder.log', data_info_entry['location'] + '/eventbuilder.log')
        open('eventbuilder.log', mode='w').close()

        if not args.secret_mode:
            data_info_entry['status'] = 'verifying'
            runs.update({'_id': run_doc['_id'],
                         'data.host': data_info_entry['host']},
                        {'$set': {'data.$': data_info_entry}})

        # If we're trying to build a single run, don't try again to find it
        if args.run_name or args.run:
            break


def setup_logging(loglevel='DEBUG'):
    # Set up logging to file
    logging.basicConfig(level=loglevel,
                        format='%(asctime)s %(name)s %(levelname)-8s %(message)s',
                        datefmt='%m-%d %H:%M',
                        filename='eventbuilder.log',
                        filemode='w')
    # define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    # set a format which is simpler for console use
    formatter = logging.Formatter('%(asctime)s %(name)-12s: '
                                  '%(levelname)-8s %(message)s')
    # tell the handler to use this format
    console.setFormatter(formatter)
    # add the handler to the root logger
    logging.getLogger('').addHandler(console)
    return logging.getLogger('Eventbuilder')


def get_command_line_arguments():
    """Return the parsed arguments from the command line (from ArgumentParser.parse_args())
    """
    parser = argparse.ArgumentParser(description="Build XENON1T events from the DAQ.")

    parser.add_argument('--config',
                        default=['eventbuilder'],
                        nargs='+',
                        help="Name(s) of the pax configuration(s) to use, default is eventbuilder. ")
    parser.add_argument('--config_path',
                        default=[],
                        nargs='+',
                        help="Path(s) of the configuration file(s) to use.")

    parser.add_argument('--cpus', default=1, nargs='?',
                        help="Number of CPUs to use for event building. Default is 1; can be 'all'.")
    parser.add_argument('--detector', default='tpc', type=str,
                        help="Detector to build events for")
    parser.add_argument('--log', default='INFO',
                        help="Logging level to use, e.g. DEBUG")
    parser.add_argument('--secret_mode', action='store_true',
                        help="Never write anything to the runs db. Use only for testing!")
    parser.add_argument('--wait', default=1, type=int,
                        help="Wait time before searching for new runs again if none were found (sec). "
                             "If 0, instead shuts down if no new runs are found.")

    connection_group = parser.add_argument_group(title='MongoDB connection settings')
    connection_group.add_argument('--host', default='gw', type=str,
                                  help='MongoDB hostname')
    connection_group.add_argument('--port', default=27017, type=int,
                                  help='Port on host where MongoDB runs')
    connection_group.add_argument('--user', default='eb', type=str,
                                  help='User to connect to MongoDB')
    connection_group.add_argument('--password', type=str, default=os.environ.get('MONGO_PASSWORD'),
                                  help='Password to connect to MongoDB. '
                                       'If not provided, will try to use MONGO_PASSWORD from env')

    single_run_group = parser.add_mutually_exclusive_group()
    single_run_group.add_argument('--run_name', type=str,
                                  help="Instead of building all waiting_to_be_processed runs, "
                                       "look for this specific run name and build it.")
    single_run_group.add_argument('--run', type=int,
                                  help="Instead of building all waiting_to_be_processed runs, "
                                       "look for this specific run number and build it.")

    trigger_group = parser.add_argument_group(title='Trigger settings',
                                              description='Override default settings for the trigger.')
    trigger_group.add_argument('--force_multiplicity_trigger', type=int,
                               help='Forces the trigger into a more basic mode: always trigger on a signal of more than'
                                    'force_multiplicity_trigger pulses, and never on smaller signals.')
    trigger_group.add_argument('--signal_separation', type=float,
                               help='If no pulses start for this length of time (us),'
                                    'a signal ends / a new signal can start.')
    trigger_group.add_argument('--event_separation', type=float,
                               help='If there are no triggers for this length of time (us),'
                                    'a new event can start.')
    trigger_group.add_argument('--left_extension', type=float,
                               help="Minimum range before each trigger to save (us). Is abs()ed before it is used.")
    trigger_group.add_argument('--right_extension', type=float,
                               help='Minimum time after trigger to save (us).')

    mongoreader_group = parser.add_argument_group(title='Trigger driving / Mongo reading settings')
    mongoreader_group.add_argument('--batch_window', type=float,
                                   help='Length of time range (in sec, float) to get pulse data in each query.')
    mongoreader_group.add_argument('--delete_data', action='store_true',
                                   help="Delete data from the untriggered collection while triggering on it. "
                                        "Essential for running the trigger live for an extended time!")
    mongoreader_group.add_argument('--edge_safety_margin', type=int,
                                   help="When triggering live, stay at least this many seconds "
                                        "away from the insertion edge.")
    mongoreader_group.add_argument('--max_query_workers', type=int,
                                   help="Maximum number of parallel pulse time range queries "
                                        "to fire off in the trigger.")
    mongoreader_group.add_argument('--skip_ahead', type=int, default=0,
                                   help="After triggering a batch of data, skip ahead this number of batches "
                                        "without triggering. "
                                        "Use only for dealing quickly with runs that have overflown to disk!")
    mongoreader_group.add_argument('--stop_after_sec', type=float, default=float('inf'),
                                   help="Stop the trigger after this many seconds of data have been read. "
                                        "Won't stop in the middle of a batch. Use only for testing!")

    args = parser.parse_args()
    return args

if __name__ == "__main__":
    main()
